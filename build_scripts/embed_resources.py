"""
Script to embed frontend static files into Python module for single-exe compilation.
Reads files from frontend/dist and generates backend/embedded_static.py with embedded data.
"""

import os
import base64
import gzip
import mimetypes
from pathlib import Path
import json

# Initialize mimetypes
mimetypes.init()

# Additional MIME type mappings
MIME_TYPES = {
    '.js': 'application/javascript',
    '.mjs': 'application/javascript',
    '.css': 'text/css',
    '.html': 'text/html',
    '.json': 'application/json',
    '.svg': 'image/svg+xml',
    '.png': 'image/png',
    '.jpg': 'image/jpeg',
    '.jpeg': 'image/jpeg',
    '.gif': 'image/gif',
    '.ico': 'image/x-icon',
    '.woff': 'font/woff',
    '.woff2': 'font/woff2',
    '.ttf': 'font/ttf',
    '.eot': 'application/vnd.ms-fontobject',
    '.map': 'application/json',
}

def get_mime_type(file_path: str) -> str:
    """Get MIME type for a file."""
    ext = Path(file_path).suffix.lower()
    if ext in MIME_TYPES:
        return MIME_TYPES[ext]
    
    mime_type, _ = mimetypes.guess_type(file_path)
    return mime_type or 'application/octet-stream'

def should_compress(mime_type: str) -> bool:
    """Determine if file should be compressed based on MIME type."""
    # Don't compress already compressed formats
    no_compress = ['image/', 'video/', 'audio/', 'font/', 'application/zip', 'application/gzip']
    return not any(mime_type.startswith(prefix) for prefix in no_compress)

def embed_frontend_resources(frontend_dir: str = "frontend/dist", output_file: str = "backend/embedded_static.py"):
    """
    Embed all frontend resources into a Python module.
    
    Args:
        frontend_dir: Directory containing built frontend files
        output_file: Output Python file to generate
    """
    if not os.path.exists(frontend_dir):
        print(f"Warning: Frontend build directory '{frontend_dir}' does not exist.")
        print("Creating empty embedded_static.py. Run 'npm run build' in frontend directory first.")
        frontend_dir = None
    
    embedded_files = {}
    total_size = 0
    file_count = 0
    
    if frontend_dir and os.path.exists(frontend_dir):
        # Walk through all files in frontend dist
        for root, dirs, files in os.walk(frontend_dir):
            for file in files:
                file_path = os.path.join(root, file)
                
                # Get relative path for URL
                rel_path = os.path.relpath(file_path, frontend_dir)
                url_path = '/' + rel_path.replace('\\', '/')
                
                # Read file content
                with open(file_path, 'rb') as f:
                    content = f.read()
                
                # Get MIME type
                mime_type = get_mime_type(file_path)
                
                # Optionally compress text files
                compressed = False
                if should_compress(mime_type) and len(content) > 1024:  # Only compress files > 1KB
                    compressed_content = gzip.compress(content, compresslevel=9)
                    if len(compressed_content) < len(content) * 0.9:  # Only use if >10% savings
                        content = compressed_content
                        compressed = True
                
                # Encode content
                encoded_content = base64.b64encode(content).decode('ascii')
                
                # Store in dictionary
                embedded_files[url_path] = {
                    'content': encoded_content,
                    'mime_type': mime_type,
                    'compressed': compressed,
                    'size': len(content)
                }
                
                total_size += len(content)
                file_count += 1
                
                print(f"Embedded: {url_path} ({mime_type}, {len(content):,} bytes{', compressed' if compressed else ''})")
    
    # Generate Python module
    with open(output_file, 'w', encoding='utf-8') as f:
        f.write('"""\n')
        f.write('Auto-generated embedded static resources.\n')
        f.write('DO NOT EDIT - This file is generated by build_scripts/embed_resources.py\n')
        f.write('"""\n\n')
        f.write('import base64\n')
        f.write('import gzip\n')
        f.write('from typing import Dict, Optional\n\n')
        
        f.write('# Embedded files from frontend build\n')
        f.write('EMBEDDED_FILES: Dict[str, Dict[str, any]] = {\n')
        
        for url_path, file_data in embedded_files.items():
            f.write(f'    "{url_path}": {{\n')
            f.write(f'        "content": base64.b64decode(\n')
            
            # Split long base64 strings into multiple lines
            content_str = file_data['content']
            chunk_size = 76
            for i in range(0, len(content_str), chunk_size):
                chunk = content_str[i:i+chunk_size]
                f.write(f'            "{chunk}"\n')
            
            f.write('        ),\n')
            f.write(f'        "mime_type": "{file_data["mime_type"]}",\n')
            f.write(f'        "compressed": {file_data["compressed"]},\n')
            f.write(f'        "size": {file_data["size"]}\n')
            f.write('    },\n')
        
        f.write('}\n\n')
        
        # Add helper functions
        f.write('''def get_embedded_file(path: str) -> Optional[Dict[str, any]]:
    """
    Retrieve an embedded file by its path.
    
    Args:
        path: The URL path of the file
    
    Returns:
        Dictionary with file data, or None if not found
    """
    # Normalize path
    if not path.startswith('/'):
        path = '/' + path
    
    # Try exact match
    if path in EMBEDDED_FILES:
        file_data = EMBEDDED_FILES[path].copy()
        # Decompress if needed
        if file_data.get('compressed'):
            file_data['content'] = gzip.decompress(file_data['content'])
        return file_data
    
    # Try index.html for directory paths
    if path.endswith('/') or path == '/':
        index_path = (path + 'index.html').replace('//', '/')
        if index_path in EMBEDDED_FILES:
            file_data = EMBEDDED_FILES[index_path].copy()
            if file_data.get('compressed'):
                file_data['content'] = gzip.decompress(file_data['content'])
            return file_data
    
    return None

def list_embedded_files() -> list:
    """List all embedded file paths."""
    return list(EMBEDDED_FILES.keys())

def is_embedded_mode() -> bool:
    """Check if running in embedded mode."""
    return len(EMBEDDED_FILES) > 0

def get_total_size() -> int:
    """Get total size of embedded files."""
    return sum(f['size'] for f in EMBEDDED_FILES.values())
''')
    
    print(f"\n[SUCCESS] Embedded {file_count} files, total size: {total_size:,} bytes ({total_size/1024/1024:.2f} MB)")
    print(f"[SUCCESS] Generated: {output_file}")
    
    return file_count, total_size

if __name__ == "__main__":
    # Check if we're in the right directory
    if not os.path.exists("backend") or not os.path.exists("frontend"):
        print("Error: Please run this script from the PyRobot project root directory")
        exit(1)
    
    # Embed resources
    embed_frontend_resources()